<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 876 链表的中间节点</title>
      <link href="/2020/03/24/Leetcode876/"/>
      <url>/2020/03/24/Leetcode876/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-876：链表的中间节点"><a href="#Leetcode-876：链表的中间节点" class="headerlink" title="Leetcode 876：链表的中间节点"></a>Leetcode 876：链表的中间节点</h1><blockquote><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><blockquote><p>示例 1：<br>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 </p></blockquote><blockquote><p>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点</p></blockquote><p><strong>思路</strong><br>统计链表总的节点个数cnt<br>返回中间的那个节点<strong>(即cnt/2)</strong>的ListNode<br>之前可能会一愣，为什么cnt为奇数偶数的时候都是返回cnt/2的那个值，按照例子跑一遍会发现结果是一样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        ListNode* temp &#x3D; head;</span><br><span class="line">        while(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            temp &#x3D; temp -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag &#x3D; cnt&#x2F;2;</span><br><span class="line">        ListNode* ans &#x3D; head;</span><br><span class="line">        for(int i&#x3D;0;i&lt;flag;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans &#x3D; ans-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 409 最长回文串</title>
      <link href="/2020/03/23/Leetcode409/"/>
      <url>/2020/03/23/Leetcode409/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-409-最长回文串"><a href="#Leetcode-409-最长回文串" class="headerlink" title="Leetcode 409:最长回文串"></a>Leetcode 409:最长回文串</h1><blockquote><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p></blockquote><blockquote><p>注意:<br>假设字符串的长度不会超过 1010。</p></blockquote><blockquote><p>示例 1:<br>输入:<br>    “abccccdd”<br>输出:<br>    7<br>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。</p></blockquote><p><strong>思路</strong><br>1.首先统计大写字母和小写字母的字符数量</p><p>2.统计完之后，数量为偶数的字符可计入回文字符串的长度</p><p>3.如果统计完所有字符还有字符剩下，可作为回文串字符最中间的那个字符，此时，回文字符串的长度+1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindrome(string s) &#123;</span><br><span class="line">        int hash[58] &#x3D; &#123;0&#125;;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[i] - &#39;A&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;58;i++)&#123;</span><br><span class="line">            ans +&#x3D; (hash[i]&#x2F;2)*2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans&lt;s.length())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 150 计算后缀表达式的值</title>
      <link href="/2020/03/06/Leetcode150/"/>
      <url>/2020/03/06/Leetcode150/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-150-计算逆波兰式（后缀表达式）的值"><a href="#LeetCode-150-计算逆波兰式（后缀表达式）的值" class="headerlink" title="LeetCode 150:计算逆波兰式（后缀表达式）的值"></a>LeetCode 150:计算逆波兰式（后缀表达式）的值</h1><blockquote><p>运算符仅包含”+”,”-“,”*“和”/“，被操作数可能是整数或其他表达式<br>例如：<br>  [“2”, “1”, “+”, “3”, “*“] -&gt; ((2 + 1) * 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p></blockquote><p>这道题整体思路就是使用<strong>栈</strong>，对于字符串进行处理，<br>1.遇到数字直接压入栈，<strong>注意</strong>这里为char类型的数字，所以需要转换为int</p><p>2.遇到”+”,”-“,”*“和”/“符号时，将栈中的两个数字弹出进行计算，再压入栈中</p><p>3.最后直到字符串处理完，栈中只剩下一个数字，得到结果</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt; &amp;tokens) &#123;</span><br><span class="line">        if(tokens.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;int&gt; numbers;</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;0;i &lt; tokens.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s &#x3D; tokens[i];</span><br><span class="line">            if(s &#x3D;&#x3D; &quot;+&quot;||s &#x3D;&#x3D; &quot;-&quot;||s &#x3D;&#x3D; &quot;*&quot;||s &#x3D;&#x3D; &quot;&#x2F;&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(numbers.size() &lt; 2) </span><br><span class="line">                &#123;</span><br><span class="line">                    return 0;&#x2F;&#x2F;计算结果时，stack至少2个数，否则不合法，返回0</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                int num2 &#x3D; numbers.top();</span><br><span class="line">                numbers.pop();</span><br><span class="line">                int num1 &#x3D; numbers.top();</span><br><span class="line">                numbers.pop();</span><br><span class="line">                </span><br><span class="line">                int result;</span><br><span class="line">                </span><br><span class="line">                if(s &#x3D;&#x3D; &quot;+&quot;)</span><br><span class="line">                    result &#x3D; num1 + num2;</span><br><span class="line">                else if(s &#x3D;&#x3D; &quot;-&quot;)</span><br><span class="line">                    result &#x3D; num1 - num2;</span><br><span class="line">                else if(s &#x3D;&#x3D; &quot;*&quot;)</span><br><span class="line">                    result &#x3D; num1 * num2;</span><br><span class="line">                else if(s &#x3D;&#x3D; &quot;&#x2F;&quot;)</span><br><span class="line">                    result &#x3D; num1 &#x2F; num2;</span><br><span class="line">                </span><br><span class="line">                numbers.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                stringstream ss; &#x2F;&#x2F;字符串转数字技巧</span><br><span class="line">                ss&lt;&lt;s;</span><br><span class="line">                int temp;</span><br><span class="line">                ss&gt;&gt;temp;</span><br><span class="line">                numbers.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><hr><h2 id="C-栈-Stack"><a href="#C-栈-Stack" class="headerlink" title="C++ 栈 Stack"></a>C++ 栈 Stack</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt; &#x2F;&#x2F;头文件</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt;  stack1;   &#x2F;&#x2F;定义类型为int的空栈</span><br><span class="line"></span><br><span class="line">empty()     &#x2F;&#x2F;堆栈为空则返回真</span><br><span class="line">pop()       &#x2F;&#x2F;移除栈顶元素,没有返回值!!!</span><br><span class="line">push()      &#x2F;&#x2F;在栈顶增加元素,没有返回值</span><br><span class="line">size()      &#x2F;&#x2F;返回栈中元素数目</span><br><span class="line">top()       &#x2F;&#x2F;top函数的返回值是栈顶元素,注意并没有删掉栈顶元素!!</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 149 求直线上最多的点数</title>
      <link href="/2020/03/05/Leetcode149/"/>
      <url>/2020/03/05/Leetcode149/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-149-max-points-on-a-line"><a href="#LeetCode-149-max-points-on-a-line" class="headerlink" title="LeetCode 149 max-points-on-a-line"></a>LeetCode 149 max-points-on-a-line</h1><blockquote><p>对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上<br>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p></blockquote><p>二重遍历循环，构建 斜率-&gt;点的数量 map<br>第一重循环遍历起始点x，第二重遍历剩余的点y<br>x,y重合，则经过x的所有直线点数dup+1；<br>x与y不重合，x与y斜率k的直线点数+1，期间考虑垂直的情况，垂直时k=0</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * struct Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() : x(0), y(0) &#123;&#125;</span><br><span class="line"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxPoints(vector&lt;Point&gt; &amp;points) &#123;</span><br><span class="line">        int size &#x3D; points.size();</span><br><span class="line">        if(size &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(size &#x3D;&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 0;i&lt;size;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            int curmax &#x3D; 1;</span><br><span class="line">            map&lt;double,int&gt;mp;</span><br><span class="line">            int vcnt &#x3D; 0;  &#x2F;&#x2F;垂直点的个数</span><br><span class="line">            int dup &#x3D; 0;   &#x2F;&#x2F;重复点的个数</span><br><span class="line">            for(int j &#x3D; 0;j&lt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j !&#x3D; i)</span><br><span class="line">                &#123;</span><br><span class="line">                    double x1 &#x3D; points[i].x - points[j].x;</span><br><span class="line">                    double y1 &#x3D; points[i].y - points[j].y;</span><br><span class="line">                    if(x1 &#x3D;&#x3D; 0 &amp;&amp; y1 &#x3D;&#x3D; 0) &#x2F;&#x2F;说明是重复点</span><br><span class="line">                    &#123;</span><br><span class="line">                        dup++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(x1&#x3D;&#x3D;0) &#x2F;&#x2F;垂直点</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(vcnt&#x3D;&#x3D;0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            vcnt &#x3D; 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else&#123; &#x2F;&#x2F;说明之前该点已经统计过一次</span><br><span class="line">                            vcnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        curmax &#x3D; max(vcnt,curmax);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        double k &#x3D; y1&#x2F;x1;</span><br><span class="line">                        if(mp[k] &#x3D;&#x3D; 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            mp[k] &#x3D; 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else&#123;</span><br><span class="line">                            mp[k]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        curmax &#x3D; max(mp[k],curmax);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans &#x3D; max(ans,dup+curmax);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><hr><h2 id="C-map知识点"><a href="#C-map知识点" class="headerlink" title="C++ map知识点"></a>C++ map知识点</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><blockquote><p>map 是STL的一个关联容器，提供<strong>一对一</strong>的键值对 key-value对应<br>其中关键字key在map中只能出现一次</p></blockquote><blockquote><p>map可存储任意类型的数据，包括自定义的数据类型<br>内部使用红黑树，复杂度基本是lg(N)</p></blockquote><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;       &#x2F;&#x2F;注意点：STL头文件没有扩展名.h</span><br><span class="line"></span><br><span class="line">定义</span><br><span class="line">    map&lt;int,string&gt; stu</span><br><span class="line"></span><br><span class="line">插入元素</span><br><span class="line">    stu.insert(pair&lt;int,string&gt;(666,&quot;Me&quot;));</span><br><span class="line">    stu.insert(map&lt;int,sting&gt;::value_type(666,&quot;Me&quot;))</span><br><span class="line">    stu[666] &#x3D; &quot;Me&quot;  &#x2F;&#x2F;常用</span><br><span class="line"></span><br><span class="line">寻找元素</span><br><span class="line">    &#x2F;&#x2F;查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，不存在则返回map::end()的值</span><br><span class="line">    location &#x3D; find(&quot;666&quot;) </span><br><span class="line"></span><br><span class="line">    string stu1 &#x3D; stu[666];  &#x2F;&#x2F;获得key&#x3D;666对应的value值</span><br><span class="line"></span><br><span class="line">删除元素</span><br><span class="line">    iterator erase(iterator it);&#x2F;&#x2F;通过一个条目对象删除</span><br><span class="line">    iterator erase(iterator first,iterator last);&#x2F;&#x2F;删除一个范围</span><br><span class="line">    size_type erase(const Key&amp; key);&#x2F;&#x2F;通过关键字删除</span><br><span class="line"></span><br><span class="line">    栗子</span><br><span class="line">    iter &#x3D; mapStudent.find(&quot;666&quot;);</span><br><span class="line">    mapStudent.erase(iter); &#x2F;&#x2F;迭代器删除</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;用关键字刪除</span><br><span class="line">    int n &#x3D; mapStudent.erase(&quot;123&quot;); &#x2F;&#x2F;如果刪除了会返回1，否則返回0</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;用迭代器范围刪除 : 把整个map清空</span><br><span class="line">    mapStudent.erase(stu.begin(), stu.end());</span><br><span class="line">    &#x2F;&#x2F;等同于mapStudent.clear()</span><br><span class="line"></span><br><span class="line">其他基本操作</span><br><span class="line">    begin()         返回指向map头部的迭代器</span><br><span class="line">    end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">    erase()         删除一个元素</span><br><span class="line">    find()          查找一个元素</span><br><span class="line"></span><br><span class="line">    clear(）        删除所有元素</span><br><span class="line">    empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">    count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">    size()          当前已经插入了多少数据，size函数,返回int</span><br><span class="line">    insert()        插入元素</span><br><span class="line"></span><br><span class="line">    swap()           交换两个map</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 111 二叉树的最小深度</title>
      <link href="/2020/03/04/Leetcode111/"/>
      <url>/2020/03/04/Leetcode111/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-111-二叉树的最小深度"><a href="#LeetCode-111-二叉树的最小深度" class="headerlink" title="LeetCode 111:二叉树的最小深度"></a>LeetCode 111:二叉树的最小深度</h1><blockquote><p>求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。</p></blockquote><blockquote><p>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="1-递归求解"><a href="#1-递归求解" class="headerlink" title="1 递归求解"></a>1 递归求解</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        int minimum &#x3D; 0;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return minimum;</span><br><span class="line">        &#125;</span><br><span class="line">        int ld &#x3D; run(root-&gt;left); &#x2F;&#x2F;递归求解</span><br><span class="line">        int rd &#x3D; run(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">       if(ld * rd &gt; 0) &#x2F;&#x2F;考虑非完全二叉树的情况</span><br><span class="line">        &#123;</span><br><span class="line">            return (ld&gt;rd?rd:ld)+1; </span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;左右子树有一个深度为0，所以取大的深度继续递归</span><br><span class="line">        &#123;</span><br><span class="line">            return (ld&gt;rd?ld:rd)+1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) return 0;</span><br><span class="line">        if (root-&gt;left &#x3D;&#x3D; nullptr) return run(root-&gt;right) + 1;</span><br><span class="line">        if (root-&gt;right &#x3D;&#x3D; nullptr) return run(root-&gt;left) + 1;</span><br><span class="line">        return min(run(root-&gt;left) , run(root-&gt;right)) + 1;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="2-非递归，BFS"><a href="#2-非递归，BFS" class="headerlink" title="2 非递归，BFS"></a>2 非递归，BFS</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        int depth &#x3D; 0;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            int size &#x3D; que.size();  &#x2F;&#x2F;当前待遍历层的结点数</span><br><span class="line">            depth++;</span><br><span class="line">            &#x2F;&#x2F;遍历当前层</span><br><span class="line">            for(int i &#x3D; 0; i &lt; size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp &#x3D; que.front();</span><br><span class="line">                if(tmp-&gt;left !&#x3D; NULL)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                if(tmp-&gt;right !&#x3D; NULL)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">                que.pop();</span><br><span class="line">                &#x2F;&#x2F; 找到第一个叶子节点，返回</span><br><span class="line">                if(tmp-&gt;left &#x3D;&#x3D; NULL &amp;&amp; tmp-&gt;right &#x3D;&#x3D; NULL)</span><br><span class="line">                    return depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="C-queue-复习总结"><a href="#C-queue-复习总结" class="headerlink" title="C++ queue 复习总结"></a>C++ queue 复习总结</h2><p>FIFO 不能随机存取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;queue&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> </span><br><span class="line">定义</span><br><span class="line"> queue&lt;elem&gt; queT; &#x2F;&#x2F;queue 采用模板类实现，queue 对象的默认构造形式：</span><br><span class="line"> </span><br><span class="line">插入删除</span><br><span class="line">push(elem);&#x2F;&#x2F;往队尾添加元素</span><br><span class="line">pop();     &#x2F;&#x2F;从队头移除第一个元素</span><br><span class="line">back();   &#x2F;&#x2F;返回最后一个元素</span><br><span class="line">front();  &#x2F;&#x2F;返回第一个元素</span><br><span class="line"></span><br><span class="line">赋值操作</span><br><span class="line">queue&amp; operator&#x3D;(const queue &amp;que);&#x2F;&#x2F;重载等号操作</span><br><span class="line"></span><br><span class="line">empty();  &#x2F;&#x2F;判断队列是否为空,如果为空则返回true</span><br><span class="line">size();  &#x2F;&#x2F;返回队列的大小</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 54 螺旋矩阵I</title>
      <link href="/2020/03/03/Leetcode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5I/"/>
      <url>/2020/03/03/Leetcode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5I/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-54：螺旋矩阵I"><a href="#Leetcode-54：螺旋矩阵I" class="headerlink" title="Leetcode 54：螺旋矩阵I"></a>Leetcode 54：螺旋矩阵I</h1><p> <a href="https://i.loli.net/2020/03/03/q59FYCVy4cxsIth.png" data-fancybox="group" data-caption="KNGU____O__DPNOF73UAL21.png" class="fancybox"><img alt="KNGU____O__DPNOF73UAL21.png" data-src="https://i.loli.net/2020/03/03/q59FYCVy4cxsIth.png" class="lazyload" title="KNGU____O__DPNOF73UAL21.png"></a></p><p> 整体思路是按题目要求模拟，顺时针转，先从左到右，再从上到下<br> 最后从右到左，从下到上，注意点在于边界值控制</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">       if(matrix.empty() || matrix[0].empty())</span><br><span class="line">       &#123;</span><br><span class="line">           return &#123;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       int m &#x3D; matrix.size();</span><br><span class="line">       int n &#x3D; matrix[0].size();</span><br><span class="line"></span><br><span class="line">       int up &#x3D; 0,left &#x3D; 0;</span><br><span class="line">       int down &#x3D; m-1,right &#x3D; n-1;</span><br><span class="line"></span><br><span class="line">       ventor&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">       while(up&lt;&#x3D;down &amp;&amp; left&lt;&#x3D;right)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int i &#x3D; left;i &lt;&#x3D; right;i++)    &#x2F;&#x2F; 注意&lt;&#x3D; [left,right]</span><br><span class="line">           &#123;</span><br><span class="line">               res.push_back(matrix[up][i]);</span><br><span class="line">           &#125;</span><br><span class="line">           for(int i &#x3D; up + 1;i &lt;&#x3D; down;i++)   &#x2F;&#x2F;注意+1 &lt;&#x3D; (up,down]</span><br><span class="line">           &#123;</span><br><span class="line">               res.push_back(matrix[i][right]);</span><br><span class="line">           &#125;</span><br><span class="line">           if(up&lt;down &amp;&amp; left&lt;right)</span><br><span class="line">           &#x2F;&#x2F;当up&#x3D;&#x3D;down的时候我们实际上只有一行要输出，上面已经输出了</span><br><span class="line">           &#123;</span><br><span class="line">               for(int i &#x3D; right - 1;i &gt; left;i--)  &#x2F;&#x2F;[right,left)</span><br><span class="line">               &#123;</span><br><span class="line">                    res.push_back(matrix[down][i]);</span><br><span class="line">               &#125;</span><br><span class="line">               for(int i &#x3D; down;i &gt; up;i--)        &#x2F;&#x2F;(down,up)</span><br><span class="line">               &#123;</span><br><span class="line">                    res.push_back(matrix[i][left]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 59 螺旋矩阵Ⅱ</title>
      <link href="/2020/03/02/Leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/"/>
      <url>/2020/03/02/Leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-59：螺旋矩阵-Ⅱ"><a href="#Leetcode-59：螺旋矩阵-Ⅱ" class="headerlink" title="Leetcode 59：螺旋矩阵 Ⅱ"></a>Leetcode 59：螺旋矩阵 Ⅱ</h1><p><a href="https://s2.ax1x.com/2020/03/02/3fVVSJ.png" data-fancybox="group" data-caption="3fVVSJ.png" class="fancybox"><img alt="3fVVSJ.png" data-src="https://s2.ax1x.com/2020/03/02/3fVVSJ.png" class="lazyload" title="3fVVSJ.png"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按数字增长方向排列模拟来就行，按从左到右，从上到下，再从右到左，从左到右。<strong>最主要的是定义好边界值!</strong> 将每次循环的行列值定下来。用行列起始位置来标定，更加清晰。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; matrix(n,vector&lt;int&gt;(n));</span><br><span class="line"></span><br><span class="line">int row_start&#x3D;0,row_end&#x3D;n-1;</span><br><span class="line">int col_strat&#x3D;0,col_end&#x3D;n-1;</span><br><span class="line">int num&#x3D;1；</span><br><span class="line"></span><br><span class="line">for(;num&lt;&#x3D;n*n;)</span><br><span class="line">&#123;</span><br><span class="line">for(int i&#x3D;col_start;i&lt;&#x3D;col_end;i++)</span><br><span class="line">&#123;</span><br><span class="line">matrix[row_start][i] &#x3D; num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">row_start++;</span><br><span class="line">for(int i&#x3D;row_start;i&lt;&#x3D;row_end;i++)</span><br><span class="line">&#123;</span><br><span class="line">matrix[i][col_end] &#x3D; num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">col_end--;</span><br><span class="line">for(int i&#x3D;col_end;i&gt;&#x3D;col_start;i--)</span><br><span class="line">&#123;</span><br><span class="line">matrix[row_end] [i] &#x3D; num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">row_end--;</span><br><span class="line">for(int i&#x3D;row_end;i&gt;&#x3D;row_start;i--)</span><br><span class="line">&#123;</span><br><span class="line">matrix[i][col_start] &#x3D; num;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">col_start++;</span><br><span class="line">&#125;</span><br><span class="line">return matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="做题遇到的”新”东西"><a href="#做题遇到的”新”东西" class="headerlink" title="做题遇到的”新”东西"></a>做题遇到的”新”东西</h2><h3 id="1-new-delete-new-delete"><a href="#1-new-delete-new-delete" class="headerlink" title="1 new/delete new[]/delete[]"></a>1 <code>new/delete new[]/delete[]</code></h3><p>  很久没碰代码，这个C++基础的东西都忘记了，哭唧唧。</p><p>  原本想申请动态内存都使用<code>new</code>的，后面发现题目已经给了 <code>vector</code>；</p><p>  这里复习一下<code>new/delete</code><br>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1. new 和 delete 不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。</span><br><span class="line"> </span><br><span class="line"> 2.  C++ 语言标准库的库函数原型:</span><br><span class="line">void *operator new(size_t);     &#x2F;&#x2F;allocate an object</span><br><span class="line">void *operator delete(void *);    &#x2F;&#x2F;free an object</span><br><span class="line"></span><br><span class="line">void *operator new[](size_t);     &#x2F;&#x2F;allocate an array</span><br><span class="line">void *operator delete[](void *);    &#x2F;&#x2F;free an array</span><br><span class="line"></span><br><span class="line">3.用法</span><br><span class="line">&gt;申请&#x2F;释放指针</span><br><span class="line">int *pi &#x3D; new int(10);   &#x2F;&#x2F;分配一个int型变量所占大小的空间，在其中放入十进制数10，并将首地址赋给int *型指针pi。</span><br><span class="line">delete pi;</span><br><span class="line"></span><br><span class="line">&gt;申请&#x2F;释放一维数组</span><br><span class="line">string *ps &#x3D; new string[10];      &#x2F;&#x2F;array of 10 empty string</span><br><span class="line">delete [] ps;</span><br><span class="line"></span><br><span class="line">&gt;申请&#x2F;释放二维数组</span><br><span class="line">int **arr &#x3D; NULL;</span><br><span class="line">arr &#x3D; new int*[m];</span><br><span class="line">for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     arr[i] &#x3D; new int[n];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">delete[] arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 <code>vector</code></h3><p>  vector是C++标准模板库中的内容，vector之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;   &#x2F;&#x2F;头文件</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;test;&#x2F;&#x2F;建立一个vector</span><br><span class="line">test.push_back(1);</span><br><span class="line">test.push_back(2);&#x2F;&#x2F;把1和2压入vector这样test[0]就是1,test[1]就是2</span><br><span class="line"></span><br><span class="line">int i &#x3D;test.at(1);&#x2F;&#x2F;i为2</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m,vector&lt;int&gt;(n)); &#x2F;&#x2F;此定义方法错误</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; matrix(m,vector&lt;int&gt;(n));</span><br><span class="line"></span><br><span class="line">含义：定义了一个vector容器，元素类型为vector&lt;int&gt;，初始化为包含m个vector&lt;int&gt;对象，每个对象都是一个新创立的vector&lt;int&gt;对象的拷贝，而这个新创立的vector&lt;int&gt;对象被初始化为包含n个0。</span><br><span class="line"></span><br><span class="line">每部分解析：</span><br><span class="line">　　构造函数vector(size_type n, const allocator_type&amp; alloc &#x3D; allocator_type())</span><br><span class="line">　　表示构造一个使用alloc分配内存（如果是初学，不用管这个，使用默认的就好）的含n个元素的vector，</span><br><span class="line">　　其中每个元素执行值初始化（对于内置类型即初始化为0）。因此vector&lt;int&gt;(n)表示构造一个无名且含n个0的vector&lt;int&gt;对象。</span><br><span class="line">　　</span><br><span class="line">　　构造函数vector(size_type n, const value_type&amp; val, const allocator_type&amp; alloc &#x3D; allocator_type())</span><br><span class="line">　　表示构造一个使用alloc分配内存的含n个元素的vector，其中每个元素是val的一个拷贝。访问某元素时，方法和二维数组相同。</span><br><span class="line">　　</span><br><span class="line">　　从结果上看，类似于创建了一个m×n的二维数组，而且可以通过v[i][j]的方式来访问元素（vector支持下标访问元素）。</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timing（时机）---有想做的事情就赶快去做吧！</title>
      <link href="/2020/03/01/2020-3-1/"/>
      <url>/2020/03/01/2020-3-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>但是缘分<br>还有<strong>时机</strong><br>不是自动找上门的偶然<br>是带着恳切的期盼做出的无数选择<br>创造奇迹般的瞬间<br><strong>毫不犹豫的放弃和当机立断</strong><br>弄出了时机</p><blockquote><p>那家伙更恳切<br><strong>我应该鼓起更大的勇气</strong><br>搞怪的不是红绿灯<br>也不是时机<br><strong>而是我数不清的犹豫</strong></p></blockquote><p> ——————《请回答1988》</p></blockquote><h1 id="0-Background"><a href="#0-Background" class="headerlink" title="0 Background"></a>0 Background</h1><p>这个寒假看了被周围人推荐了很多次的《<strong>请回答1988</strong>》，里面很多台词独白真的直击内心。<strong>看完了好久都没从里面走不出来</strong>，刷新了我对韩剧的认知，这也是我第一次看韩剧，真的完全刷新了我以前对于韩剧都是欧巴欧巴的那种排斥感。</p><p>也是第一次知道青春剧还能这样拍，也挺羡慕里面的双门洞五人帮的，害，越来越觉得独生子女好可怜嗷/(ㄒoㄒ)/~~</p><p>上头到什么境界呢，这里面的韩语歌《青春》《你不要担心》《每天和你》….我都开始循环听了起来，╮(╯▽╰)╭<br><a href="https://pic.downk.cc/item/5e5cc5fb98271cb2b8a9ac32.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://pic.downk.cc/item/5e5cc5fb98271cb2b8a9ac32.jpg" class="lazyload" title></a></p><h1 id="1-idea"><a href="#1-idea" class="headerlink" title="1 idea"></a>1 idea</h1><p>前面截取的《请回答1988》里的台词是狗焕的独白，在他自己看见阿泽先他一步到了演唱会和德善一起去看演唱会，又听广播知道阿泽是放弃了围棋比赛（这是阿泽第一次主动弃赛）去陪德善之后，真正明白自己真的已经错过德善之后，对自己说的一段话。</p><p>时机（Timing）<strong>不是</strong>自动找上门的<strong>偶然</strong>，是带着<strong>恳切的期盼</strong>做出的无数选择，创造奇迹般的瞬间，<strong>毫不犹豫的放弃和当机立断</strong>，弄出了时机。那家伙更恳切，<strong>我应该鼓起更大的勇气</strong>，搞怪的不是红绿灯，也不是时机，<strong>而是我数不清的犹豫</strong>。</p><p>以前大一大二没思考过自己今后到底要做什么。大三上学期思考得尤其多了起来，是按照计算机专业的一般路子进互联网大厂技术岗每天996，还是<del>轻松一点</del>的非技术岗产品经理或者产品策划？是沉迷学术研究最后做一个教授？好像进深圳教育系统当个老师也不错诶？</p><p>如此的想法好像有千万个，每天我都能换一种想法，好像这个也挺好，那个也不赖诶，我变得麻木，不知道自己的方向，问问自己的初心，好像初心也模糊了起来。 最后我开始问自己：<strong>你自己到底喜欢做什么?</strong> 我竟然一时半会真答不上来。一直觉得做自己喜欢的事情生活才能越活越觉得舒坦，而我，真的一时半会没有发现我喜欢做什么。<br>一直思来想去，好像真没什么事情是能让我源源不断有能量一直去做的。<br>安排的任务，不管是不是我真正喜欢的，只要是确定了必须要做的，我都尽自己最大努力去做，对各种各样的东西开始无感起来。<strong>感觉没找到自己热爱的东西就像机器一般无所谓地转来转去。</strong></p><p>一直在不停地问你自己，<em>你喜欢什么呀</em> 为什么那么多人都准确地知道自己想要做什么，我为什么又连想做的事情都没有，知道自己想做什么怎么这么难？知道要多去尝试，往各方面尝试？知道应该好好努力，课堂里学的东西远远不够，可是这动力去哪了呢？道理都懂，怎么就过不好了？</p><h1 id="2-hesitate"><a href="#2-hesitate" class="headerlink" title="2 hesitate"></a>2 hesitate</h1><p>当下的自己，只能不断尝试，想在今年暑假找份实习，做做互联网程序员的工作，体验一番看自己喜欢不喜欢。</p><p>目前唯一发现让自己感到特别开心的事情就是<strong>帮助别人</strong>，<strong>影响别人</strong>，这一点教师这个职业就很符合。以后自己会从事教育行业吗？我也不得而知，现在太年轻，想法也一天一个样。</p><p>好像说了半天也没扯上<strong>时机</strong>，<strong>犹豫</strong>，<strong>勇气</strong>。<br>不慌，马上就来了。</p><p>薛老师在计算机设计与实践群里发了招募计算机组成原理实验课助教的通知，我看到消息的第一反应有想去的冲动，我还是挺喜欢做一个助教的，能帮助到好多人啊，<strong>冲动过后就只剩犹豫</strong>，犹豫自己是不是还抽得出时间？大三下课程也不少，看了下时间好像也并不是绝对冲突到不可能去做这件事。是不是能够胜任助教的工作？毕竟Verilog还有计算机组成原理的东西忘记得差不多了。反正想了好多问题，<strong>犹犹豫豫，最后就没报名。</strong><br>直到后面薛老师又发了一次通知，助教没招满还可以继续报名。其实我还是犹豫，把那些问题又仔细思考了一遍。最后想：报个名吧，要是满了就算和这个助教工作没缘分了。结果一报名薛老师就说可以，还没满。当时的内心一半激动一半自责。</p><p>你不是一直觉得没有你喜欢做的事情吗?现在你既然喜欢做，为什么第一时间不去报名呢？犹犹豫豫，你难道还在等什么时机吗？还像狗焕一样吗？搞怪一切的，可能就是你数不清的犹豫。<br>Dear myself，我希望你以后能<strong>毫不犹豫、当机立断，有着勇气去做你自己喜欢的事情</strong>。</p><p>类似的事情以前也发生过，有些想做的事情犹豫不去做以后可能会后悔一辈子的啊。</p><h1 id="3-future"><a href="#3-future" class="headerlink" title="3 future"></a>3 future</h1><p>给自己的一句话：<strong>有想做的事情就赶快去做吧!</strong> 别犹豫，思考过后立马行动哈，有想法有喜欢做的事情难能可贵，别弄丢它们了。时机不是自动找上门的偶然，是带着恳切的期盼做出的无数选择。希望你能真正找到自己喜欢做的事情啊！<br><a href="https://s2.ax1x.com/2020/03/02/3WE6BV.png" data-fancybox="group" data-caption="3WE6BV.png" class="fancybox"><img alt="3WE6BV.png" data-src="https://s2.ax1x.com/2020/03/02/3WE6BV.png" class="lazyload" title="3WE6BV.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Grow_Up </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++开发的学习路线</title>
      <link href="/2020/02/29/C++Studyline/"/>
      <url>/2020/02/29/C++Studyline/</url>
      
        <content type="html"><![CDATA[<h1 id="0-overview"><a href="#0-overview" class="headerlink" title="0 overview"></a>0 overview</h1><p>害，都大三下学期了，感觉自己啥也没学到，不会写的代码还是不会写，面对各类课程实验有时还是有点恐惧心理。</p><p>说到底还是自己菜，能力不太行，学校学的东西远远不够。而原本想暑假找份实习在公司里摸爬滚打一下，面试的时候被面试官问得一问三不知，才知道原来自己真的好像没学到什么东西，整个学习路线也不清晰。</p><p>在B站碰巧那几天看到 <a href="https://www.bilibili.com/video/av91838886" target="_blank" rel="noopener">Codesheep发的C语言和C++的学习路线</a>  才明白自己学到的真的少之又少。</p><p>这里依据视频总结一下C/C++开发的学习路线，勉励自己按照此路线好好学习。<br>(ง •_•)ง加油吧，骚年！</p><h1 id="1-C-C-基本语法，编程思想学习"><a href="#1-C-C-基本语法，编程思想学习" class="headerlink" title="1 C/C++基本语法，编程思想学习"></a>1 C/C++基本语法，编程思想学习</h1><p>企业级开发不会在Windows下，都是Linux！<br>推荐书籍<br> 《C Primer Plus》,《 C和指针》，《C专家编程》</p><h1 id="2-数据结构与算法"><a href="#2-数据结构与算法" class="headerlink" title="2 数据结构与算法"></a>2 数据结构与算法</h1><p>直接决定能不能找到技术岗职位，技术岗很多要求在线编程解算法题</p><p>字符串，链表，树，堆栈，哈希表等…<br>刷一刷leetcode，剑指offer</p><p>之前我也刷过题，但是刷过以后，很久不碰又忘得一干二净┭┮﹏┭┮，有学业的原因也有自己迷惘的原因，今后争取刷题的时候写一下博客！</p><h1 id="3-计算机网络"><a href="#3-计算机网络" class="headerlink" title="3 计算机网络"></a>3 计算机网络</h1><p>面试经常问各种问题，基本围绕在TCP/IP协议栈里</p><p>各种协议的原理要知道，七层五层了解</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;HTTPS</span><br><span class="line">TCP&#x2F;UDP</span><br><span class="line">IP,ARP,ICMP</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>推荐书籍:《TCP/IP详解》</p><h1 id="4-操作系统"><a href="#4-操作系统" class="headerlink" title="4 操作系统"></a>4 操作系统</h1><p>进程和线程<br>进程间通信方式<br>并发，原子性，锁<br>内存，内存调度算法<br>推荐书籍：《深入理解操作系统》CSAPP</p><h1 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5 设计模式"></a>5 设计模式</h1><p>23种不一定都要会，但是基本的一定要掌握</p><blockquote><p>单例、工厂、代理、策略模式，模板方法</p></blockquote><p>推荐书籍：《大话设计模式》</p><p><del>设计模式我目前一窍不通，一点都不知道</del>/(ㄒoㄒ)/</p><h1 id="6-应用与编程实践"><a href="#6-应用与编程实践" class="headerlink" title="6 应用与编程实践"></a>6 应用与编程实践</h1><p><del>这块我也完全扑该</del></p><p>Linux操作系统基本指令，掌握 <strong>shell编程</strong> <strong>脚本</strong>等等<br>book：鸟哥的Linux私房菜 或 Linux就该这么学</p><p>编译/调试工具 <strong>Linux平台上 gcc 以及makefile</strong><br>book：跟我一起写makefile，GNU官方关于GCC和GDB的官方文档。</p><p>要会写 gdb调试工具，推荐中文版《debugging with gdb》</p><p><strong>Linux系统编程</strong><br>多线程编程 网络编程<br>book：《unix环境高级编程》《Linux高性能服务器编程》《POSIX多线程程序设计》</p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,Hexo! Windows平台下搭建自己的个人博客</title>
      <link href="/2020/02/28/Hello-Hexo/"/>
      <url>/2020/02/28/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>刚进大学就看到很多程序员总结作为技术人应该写技术博客，写博客的诸多益处就不赘述了。</p><p>去年(2019年)的某一天，在B站推送里看到了B站UP主<em>CodeSheep</em>的视频更加有了想做博客的冲动，奈何学业繁忙，计划这个寒假做博客的，由于沉迷逛B站看剧<del>无法自拔</del>，一直拖到现在╮(╯▽╰)╭，现在能把博客做起来还是挺开心的o(= ￣▽￣=)ブ</p><h1 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h1><p>搭建博客时间：2020.2.28 - 2020.2.29</p><p>框架：<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p><p>主题：<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">Butterfly</a></p><p>首先参考了<em>CodeSheep</em>的B站视频，但是由于这个视频是使用MACBook开发的，也就是macOS系统，和在Windows下开发还是有点区别，我跟着做的时候踩了很多坑。后面又找了CSDN上的一篇在windows下搭建博客的文章做参考，主题是在<em>知乎</em>上找的。<br>搭建Hexo花了一天，配主题花了一天。期间遇到的问题也搜集了很多博客，这里向我参考过的所有资料以及视频致谢！</p><p>最后贴上相关链接<br><a href="https://www.bilibili.com/video/av44544186?from=search&seid=17806130726575110106" target="_blank" rel="noopener">CodeSheep_Bilibili视频</a><br><a href="https://blog.csdn.net/qq_36759224/article/details/82121420?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">使用 Github Pages 和 Hexo 搭建自己的独立博客_CSDN</a></p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h1><hr><h2 id="0-Hexo？"><a href="#0-Hexo？" class="headerlink" title="0  Hexo？"></a>0  Hexo？</h2><p><strong>Hexo</strong>是基于<strong>node.js</strong>制作的一个快速、简洁且高效的博客框架。<br>Hexo 可以将我们通过<strong>Markdown</strong>编写的文章生成静态的html页面，可托管在<strong>Github page</strong>上，不需要额外配置服务器。</p><h2 id="1-安装Git，配置ssh密钥"><a href="#1-安装Git，配置ssh密钥" class="headerlink" title="1 安装Git，配置ssh密钥"></a>1 安装Git，配置ssh密钥</h2><p>由于之前已经在电脑里配置好Git以及ssh,这一步我直接略过了。</p><p>配置Git可参考廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p><p><strong>Tips:安装完Git可使用Git bash里敲命令行了，进入某文件目录右键即可点击Git bash，不需要cmd了</strong></p><h2 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2 安装nodejs"></a>2 安装nodejs</h2><p>需要安装nodejs以及里面的npm工具<br>（<del>不知为何我配置的时候总是把npm打成nmp</del>  ╮(╯▽╰)╭）<br>Windows：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>选择LTS版本</p><p><a href="https://pic.downk.cc/item/5e5b18b16127cc071366038e.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://pic.downk.cc/item/5e5b18b16127cc071366038e.png" class="lazyload" title></a></p><h2 id="3-安装-amp-初始化-Hexo"><a href="#3-安装-amp-初始化-Hexo" class="headerlink" title="3 安装&amp;初始化 Hexo"></a>3 安装&amp;初始化 Hexo</h2><h3 id="3-1-安装Hexo"><a href="#3-1-安装Hexo" class="headerlink" title="3.1 安装Hexo"></a>3.1 安装Hexo</h3><p>创建一个文件夹blog，在此文件夹下打开Git bash，使用下面的命令安装Hexo：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div><p>我使用了淘宝镜像加速</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></div><p><strong>Tips:安装完Git &amp; nodejs &amp; Hexo都可在命令行里查看版本验证是否安装成功</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git -version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></div><p>现在该安装的就已经全部安装完毕</p><h3 id="3-2-初始化hexo"><a href="#3-2-初始化hexo" class="headerlink" title="3.2 初始化hexo"></a>3.2 初始化hexo</h3><p>在blog文件夹里打开Git bash，使用下面的命令初始化hexo：<br><code>hexo init hexo</code><br>运行后blog文件夹下会下新建一个文件夹hexo(上面命令里第二个hexo可任取名字)</p><p><a href="https://s2.ax1x.com/2020/03/01/3c8SC8.jpg" data-fancybox="group" data-caption="3c8SC8.jpg" class="fancybox"><img alt="3c8SC8.jpg" data-src="https://s2.ax1x.com/2020/03/01/3c8SC8.jpg" class="lazyload" title="3c8SC8.jpg"></a></p><p>进入hexo文件夹里打开Git bash，运行以下命令：<br><code>npm install</code></p><p>新建完成后，文件夹目录下有:<br><a href="https://s2.ax1x.com/2020/03/01/3c8VU0.png" data-fancybox="group" data-caption="3c8VU0.png" class="fancybox"><img alt="3c8VU0.png" data-src="https://s2.ax1x.com/2020/03/01/3c8VU0.png" class="lazyload" title="3c8VU0.png"></a><br>其中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules: 依赖包</span><br><span class="line">public：存放生成的页面</span><br><span class="line">scaffolds：生成文章的一些模板</span><br><span class="line">source：用来存放文章</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml: 博客的配置文件</span><br></pre></td></tr></table></figure></div><p>在hexo目录下命令行运行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></div><p>打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">localhost:4000</a> 即可看见最初始的Hexo界面:<br><a href="https://s2.ax1x.com/2020/03/01/3c8LzF.jpg" data-fancybox="group" data-caption="3c8LzF.jpg" class="fancybox"><img alt="3c8LzF.jpg" data-src="https://s2.ax1x.com/2020/03/01/3c8LzF.jpg" class="lazyload" title="3c8LzF.jpg"></a></p><h2 id="4-将hexo部署到github-page上"><a href="#4-将hexo部署到github-page上" class="headerlink" title="4 将hexo部署到github page上"></a>4 将hexo部署到github page上</h2><p>登录GitHub.com后看到一个New repository，新建仓库</p><p>仓库命名要注意<strong>必须创建</strong>一个名称为你用户名后面加.github.io的仓库，<br>只有这样，将来要部署到GitHub page的时候，才会被识别。</p><p>也就是仓库名必须是 xxx.github.io   其中xxx就是你注册GitHub的用户名</p><p><strong>例如</strong>我的github用户名是BelliumTang，则仓库名就是 BelliumTang.github.io</p><p>由于之前已经配置过ssh，所以这里不需要再配置，没有配置请记得配置后再进行以下操作。<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416" target="_blank" rel="noopener">可参考廖雪峰老师Git教程远程仓库ssh配置</a></p><p>最后就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开hexo文件夹下配置文件 _config.yml，翻到最后，修改为:(YourGithubName就是你自己的GitHub账户)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourGithubName&#x2F;YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></div><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><p><code>npm install hexo-deployer-git --save</code></p><blockquote><p>安装deloy-git提示：<br> <a href="https://s2.ax1x.com/2020/02/29/3sQDaD.png" data-fancybox="group" data-caption="3sQDaD.png" class="fancybox"><img alt="3sQDaD.png" data-src="https://s2.ax1x.com/2020/02/29/3sQDaD.png" class="lazyload" title="3sQDaD.png"></a></p></blockquote><blockquote><p><strong>踩坑点</strong><br>  1.配置文件 <code>_config.yml</code> 里每个冒号后面都需要有空格，不然会出错<br>  2.下图中的错误： <code>repository</code> 后的地址必须按上文所说的以<code>https</code>开头的git仓库地址,不然也会出错<br>  <a href="https://s2.ax1x.com/2020/02/29/3sQNx1.png" data-fancybox="group" data-caption="3sQNx1.png" class="fancybox"><img alt="3sQNx1.png" data-src="https://s2.ax1x.com/2020/02/29/3sQNx1.png" class="lazyload" title="3sQNx1.png"></a></p></blockquote><p>最后在git bash中运行以下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></div><p>其中:<br>hexo clean清除了你之前生成的缓存。可缩写<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>运行完成后，浏览器中打开 <a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> 就可以看见你的博客了</p><h2 id="5-写自己的文章"><a href="#5-写自己的文章" class="headerlink" title="5 写自己的文章"></a>5 写自己的文章</h2><p>接下来你就可以正式开始写文章了。</p><p><code>hexo new name</code></p><p>name可以任取你喜欢的文章名称</p><p>然后在source/_post中打开name.md文件，就可以使用Markdown开始编辑了。<br>当你写完的时候，再运行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div><p>就部署成功了。</p><h2 id="6-换主题"><a href="#6-换主题" class="headerlink" title="6 换主题"></a>6 换主题</h2><p>Butterfly主题官方文档中有详细步骤，按照步骤来就好了：<br><a href="https://s2.ax1x.com/2020/03/01/3gJXTA.png" data-fancybox="group" data-caption="3gJXTA.png" class="fancybox"><img alt="3gJXTA.png" data-src="https://s2.ax1x.com/2020/03/01/3gJXTA.png" class="lazyload" title="3gJXTA.png"></a><br>注意首次换主题要记得安装pug以及stylus的渲染器</p><p>其他的例如：头像、标签等元素的配置按照文档一个一个去对照着去做就可以。</p><p>我下面列一个文档里没有提到的：</p><blockquote><p>如图所示如何修改浏览器框中的小图标？<br><a href="https://s2.ax1x.com/2020/03/01/32dl4J.png" data-fancybox="group" data-caption="32dl4J.png" class="fancybox"><img alt="32dl4J.png" data-src="https://s2.ax1x.com/2020/03/01/32dl4J.png" class="lazyload" title="32dl4J.png"></a></p></blockquote><blockquote><p>解决方案： 找到Butterfly主题里的配置文件 <code>_config.yml</code>更改<code>favicon</code><br><a href="https://s2.ax1x.com/2020/03/01/32dMEF.png" data-fancybox="group" data-caption="32dMEF.png" class="fancybox"><img alt="32dMEF.png" data-src="https://s2.ax1x.com/2020/03/01/32dMEF.png" class="lazyload" title="32dMEF.png"></a><br>其中<code>img</code>文件夹路径为：<br><a href="https://s2.ax1x.com/2020/03/01/32d3C9.png" data-fancybox="group" data-caption="32d3C9.png" class="fancybox"><img alt="32d3C9.png" data-src="https://s2.ax1x.com/2020/03/01/32d3C9.png" class="lazyload" title="32d3C9.png"></a></p></blockquote><p>至此就全部完成啦！o(*￣▽￣=)ブ</p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
